use anyhow::{Context as _, ensure};
use helper::bindings::{
    spin::postgres4_0_0::postgres::{Connection, DbValue, Error as PgError, ParameterValue, RowSet},
    wasi::http0_2_0::types::{IncomingRequest, OutgoingResponse, ResponseOutparam},
};

struct Component;
helper::gen_http_trigger_bindings!(Component);

// Format: "host=localhost port=5432 user=postgres password=my_password dbname=mydb"
const PG_CONNECTION_STRING: &str = "PG_CONNECTION_STRING";

impl bindings::Guest for Component {
    fn handle(request: IncomingRequest, response_out: ResponseOutparam) {
        helper::handle_result(handle(request), response_out)
    }
}

fn handle(request: IncomingRequest) -> anyhow::Result<OutgoingResponse> {
    let conn_str = get_header(&request, PG_CONNECTION_STRING)?;
    let conn = Connection::open(&conn_str)?;

    let rowset = numeric_types(&conn)?;
    ensure!(rowset.rows.iter().all(|r| r.len() == 12));
    ensure!(matches!(rowset.rows[0][11], DbValue::Floating64(f) if f == 1.0));

    let rowset = character_types(&conn)?;
    ensure!(rowset.rows.iter().all(|r| r.len() == 3));
    ensure!(matches!(rowset.rows[0][0], DbValue::Str(ref s) if s == "rvarchar"));

    let rowset = date_time_types(&conn)?;
    ensure!(rowset.rows.iter().all(|r| r.len() == 4));
    ensure!(matches!(rowset.rows[0][1], DbValue::Date((y, m, d)) if y == 2525 && m == 12 && d == 25));
    ensure!(matches!(rowset.rows[0][2], DbValue::Time((h, m, s, ns)) if h == 4 && m == 5 && s == 6 && ns == 789_000_000));
    ensure!(matches!(rowset.rows[0][3], DbValue::Datetime((y, _, _, h, _, _, ns)) if y == 1989 && h == 1 && ns == 0));
    ensure!(matches!(rowset.rows[1][1], DbValue::Date((y, m, d)) if y == 2525 && m == 12 && d == 25));
    ensure!(matches!(rowset.rows[1][2], DbValue::Time((h, m, s, ns)) if h == 14 && m == 15 && s == 16 && ns == 17));
    ensure!(matches!(rowset.rows[1][3], DbValue::Datetime((y, _, _, h, _, _, ns)) if y == 1989 && h == 1 && ns == 4));

    let rowset = json_types(&conn)?;
    ensure!(rowset.rows.iter().all(|r| r.len() == 2));
    ensure!(matches!(&rowset.rows[0][1], DbValue::Jsonb(v) if String::from_utf8_lossy(v) == r#"{"s":"hello","n":123,"b":true,"x":null}"#));
    ensure!(matches!(&rowset.rows[1][1], DbValue::Jsonb(v) if String::from_utf8_lossy(v) == r#"{"s":"world","n":234,"b":false,"x":null}"#));

    let rowset = uuid_type(&conn)?;
    ensure!(rowset.rows.iter().all(|r| r.len() == 2));
    ensure!(matches!(&rowset.rows[0][1], DbValue::Uuid(v) if v == "12345678-1234-1234-1234-123456789abc"));
    ensure!(matches!(&rowset.rows[1][1], DbValue::Uuid(v) if v == "fedcba98-fedc-fedc-fedc-fedcba987654"));

    let rowset = nullable(&conn)?;
    ensure!(rowset.rows.iter().all(|r| r.len() == 1));
    ensure!(matches!(rowset.rows[0][0], DbValue::DbNull));

    let pid1 = format!("{:?}", pg_backend_pid(&conn)?);
    let pid2 = format!("{:?}", pg_backend_pid(&conn)?);
    ensure!(pid1 == pid2);

    Ok(helper::ok_response())
}

fn numeric_types(conn: &Connection) -> Result<RowSet, PgError> {
    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_numeric_types (
            intid integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            rsmallserial smallserial NOT NULL,
            rsmallint smallint NOT NULL,
            rint2 int2 NOT NULL,
            rserial serial NOT NULL,
            rint int NOT NULL,
            rint4 int4 NOT NULL,
            rbigserial bigserial NOT NULL,
            rbigint bigint NOT NULL,
            rint8 int8 NOT NULL,
            rreal real NOT NULL,
            rdouble double precision NOT NULL
         );
    "#;

    conn.execute(create_table_sql, &[])?;

    let insert_sql = r#"
        INSERT INTO test_numeric_types
            (rsmallint, rint2, rint, rint4, rbigint, rint8, rreal, rdouble)
        VALUES
            (0, 0, 0, 0, 0, 0, 0, 1);
    "#;

    conn.execute(insert_sql, &[])?;

    let sql = r#"
        SELECT
            intid,
            rsmallserial,
            rsmallint,
            rint2,
            rserial,
            rint,
            rint4,
            rbigserial,
            rbigint,
            rint8,
            rreal,
            rdouble
        FROM test_numeric_types;
    "#;

    conn.query(sql, &[])
}

fn character_types(conn: &Connection) -> Result<RowSet, PgError> {
    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_character_types (
            rvarchar varchar(40) NOT NULL,
            rtext text NOT NULL,
            rchar char(10) NOT NULL
         );
    "#;

    conn.execute(create_table_sql, &[])?;

    let insert_sql = r#"
        INSERT INTO test_character_types
            (rvarchar, rtext, rchar)
        VALUES
            ('rvarchar', 'rtext', 'rchar');
    "#;

    conn.execute(insert_sql, &[])?;

    let sql = r#"
        SELECT
            rvarchar, rtext, rchar
        FROM test_character_types;
    "#;

    conn.query(sql, &[])
}

fn date_time_types(conn: &Connection) -> Result<RowSet, PgError> {
    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_date_time_types (
            index int2,
            rdate date NOT NULL,
            rtime time NOT NULL,
            rtimestamp timestamp NOT NULL
         );
    "#;

    conn.execute(create_table_sql, &[])?;

    // We will use this to test that we correctly decode "known good"
    // Postgres database values. (This validates our decoding logic
    // independently of our encoding logic.)
    let insert_sql_pg_literals = r#"
        INSERT INTO test_date_time_types
            (index, rdate, rtime, rtimestamp)
        VALUES
            (1, date '2525-12-25', time '04:05:06.789', timestamp '1989-11-24 01:02:03');
    "#;

    conn.execute(insert_sql_pg_literals, &[])?;

    // We will use this to test that we correctly encode Spin ParameterValue
    // objects. (In conjunction with knowing that our decode logic is good,
    // this validates our encode logic.)
    let insert_sql_spin_parameters = r#"
        INSERT INTO test_date_time_types
            (index, rdate, rtime, rtimestamp)
        VALUES
            (2, $1, $2, $3);
        "#;

    let date_pv = ParameterValue::Date((2525, 12, 25));
    let time_pv = ParameterValue::Time((14, 15, 16, 17));
    let ts_pv = ParameterValue::Datetime((1989, 11, 24, 1, 2, 3, 4));
    conn.execute(insert_sql_spin_parameters, &[date_pv, time_pv, ts_pv])?;

    let sql = r#"
        SELECT
            index,
            rdate,
            rtime,
            rtimestamp
        FROM test_date_time_types
        ORDER BY index;
    "#;

    conn.query(sql, &[])
}

fn json_types(conn: &Connection) -> Result<RowSet, PgError> {
    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_json_types (
            index int2,
            j jsonb NOT NULL
         );
    "#;

    conn.execute(create_table_sql, &[])?;

    // We will use this to test that we correctly decode "known good"
    // Postgres database values. (This validates our decoding logic
    // independently of our encoding logic.)
    let insert_sql_pg_literals = r#"
        INSERT INTO test_json_types
            (index, j)
        VALUES
            (1, jsonb('{ "s": "hello", "n": 123, "b": true, "x": null }'));
    "#;

    conn.execute(insert_sql_pg_literals, &[])?;

    // We will use this to test that we correctly encode Spin ParameterValue
    // objects. (In conjunction with knowing that our decode logic is good,
    // this validates our encode logic.)
    let insert_sql_spin_parameters = r#"
        INSERT INTO test_json_types
            (index, j)
        VALUES
            (2, $1);
        "#;

    let jsonb_pv = ParameterValue::Jsonb(r#"{ "s": "world", "n": 234, "b": false, "x": null }"#.as_bytes().to_vec());
    conn.execute(insert_sql_spin_parameters, &[jsonb_pv])?;

    let sql = r#"
        SELECT
            index,
            j
        FROM test_json_types
        ORDER BY index;
    "#;

    conn.query(sql, &[])
}

fn uuid_type(conn: &Connection) -> Result<RowSet, PgError> {
    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_uuid_type (
            index int2,
            u uuid NOT NULL
         );
    "#;

    conn.execute(create_table_sql, &[])?;

    // We will use this to test that we correctly decode "known good"
    // Postgres database values. (This validates our decoding logic
    // independently of our encoding logic.)
    let insert_sql_pg_literals = r#"
        INSERT INTO test_uuid_type
            (index, u)
        VALUES
            (1, uuid('12345678-1234-1234-1234-123456789abc'));
    "#;

    conn.execute(insert_sql_pg_literals, &[])?;

    // We will use this to test that we correctly encode Spin ParameterValue
    // objects. (In conjunction with knowing that our decode logic is good,
    // this validates our encode logic.)
    let insert_sql_spin_parameters = r#"
        INSERT INTO test_uuid_type
            (index, u)
        VALUES
            (2, $1);
        "#;

    let uuid_pv = ParameterValue::Uuid("fedcba98-fedc-fedc-fedc-fedcba987654".to_owned());
    conn.execute(insert_sql_spin_parameters, &[uuid_pv])?;

    let sql = r#"
        SELECT
            index,
            u
        FROM test_uuid
        ORDER BY index;
    "#;

    conn.query(sql, &[])
}

fn nullable(conn: &Connection) -> Result<RowSet, PgError> {
    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_nullable (
            rvarchar varchar(40)
         );
    "#;

    conn.execute(create_table_sql, &[])?;

    let insert_sql = r#"
        INSERT INTO test_nullable
            (rvarchar)
        VALUES
            ($1);
    "#;

    conn.execute(insert_sql, &[ParameterValue::DbNull])?;

    let sql = r#"
        SELECT
            rvarchar
        FROM test_nullable;
    "#;

    conn.query(sql, &[])
}

fn pg_backend_pid(conn: &Connection) -> Result<DbValue, PgError> {
    let sql = "SELECT pg_backend_pid()";

    let rowset = conn.query(sql, &[])?;

    Ok(rowset.rows[0][0].clone())
}

fn get_header(request: &IncomingRequest, header_key: impl Into<String>) -> anyhow::Result<String> {
    let header_key = header_key.into();
    helper::get_header(request, &header_key).with_context(|| format!("no {} header", header_key))
}
